# -*- coding: utf-8 -*-
"""MUSIC_GENERATION_ALL_TOOLS (18 April)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f_qyKuxAGICqTdxHJDnAlf0XAC9FhZxO

# Connect to Google Colab for accesing the Data
"""

# from google.colab import drive
# drive.mount('/content/gdrive')

"""## Getting Drive Data"""

# !cp -r /content/gdrive/MyDrive/MUSIC_GEN_PROJECT/Notebooks_Weights_Music /content

"""# Import the libraries we will use"""

# !pip install midi2audio
# !apt-get install fluidsynth
# !pip install mido
# !pip install pretty_midi
# !pip install midiutil

# imports
import glob
import pickle
import numpy
from music21 import converter, instrument, note, chord, stream
from keras.models import Sequential
from keras.layers import Dense, Dropout, LSTM, Activation
from keras.layers import BatchNormalization as BatchNorm
from keras.utils import np_utils
from keras.callbacks import ModelCheckpoint
from midi2audio import FluidSynth
import os
import shutil
from music21 import *
from pathlib import Path
import mido
import pretty_midi
from keras.optimizers import Adam
# imports
import pickle
import numpy as np
import os
from midiutil import MIDIFile
# from tensorflow.keras.callbacks import ModelCheckpoint #????
import tensorflow as tf
from keras.optimizers import Adam
import random

"""## Getting Drum Data"""

# # count the midi files used for training
# len(os.listdir("/content/Notebooks_Weights_Music/Music/drums_music_input"))

"""# Parsing the Midi Files (the data processing step):"""

def parse_piano(file):
    midi_file = converter.parse(file)

    notes_list = []
    print("Parsing %s" % file)

    # Get all notes and chords from all instruments in the MIDI file
    notes_to_parse = []
    for part in midi_file.parts:
        try:
            notes_to_parse += part.recurse().notesAndRests
        except:
            pass

    # Extract pitch names or chord tones from each note/chord element in the parsed file
    for element in notes_to_parse:
        if isinstance(element, note.Note):
            notes_list.append(str(element.pitch))
        elif isinstance(element, chord.Chord):
            notes_list.append('.'.join(str(n) for n in element.normalOrder))
    return notes_list

def parse_drums(file):
    notes_list = []
    # Load the MIDI file
    midi_data = pretty_midi.PrettyMIDI(file)

    print("Parsing %s" % file)

    # Get the drum track
    drum_track = midi_data.instruments[0]

    # Extract the note names from the drum track
    for note in drum_track.notes:
        note_name = pretty_midi.note_number_to_name(note.pitch)
        notes_list.append(note_name)

    return notes_list

def parse_guitar(file):
    notes_list = []
    # Load the MIDI file
    midi_data = pretty_midi.PrettyMIDI(file)

    print("Parsing %s" % file)

    # Get the guitar track
    guitar = None
    for instrument in midi_data.instruments:
        # Extract the note names from the guitar track
        for note in instrument.notes:
            note_name = pretty_midi.note_number_to_name(note.pitch)
            notes_list.append(note_name)

    return notes_list

"""TBD"""

# def parse_piano_pretty(file):
#     notes_list = []
#     # Load the MIDI file
#     midi_data = pretty_midi.PrettyMIDI(file)

#     print("Parsing %s" % file)

#     # Get the piano track
#     piano_track = None
#     for instrument in midi_data.instruments:
#         # Extract the note names from the piano track
#         for note in instrument.notes:
#             note_name = pretty_midi.note_number_to_name(note.pitch)
#             notes_list.append(note_name)

#     return notes_list

# parse_piano_pretty('/content/Notebooks_Weights_Music/Music/piano_music_input/Eternal_Harvest.mid')

def clean_notes(notes_list):
    """
    Clean a list of notes by removing any items that do not conform to the proper note format.
    """
    clean_list = []
    for note in notes_list:
        if "." in note:
            pass
        else:
            try:
                test = float(note)
                continue
            except:
                pass
            clean_list.append(note)
            
    return clean_list

def retrieve_notes(directory):
    """Extracts notes and chords from MIDI files in a directory"""
    notes_list = []
    tool = directory.split('/')[-1].split("_")[0]
    big_dir = '/'.join(directory.split('/')[:-1])
    # Iterate through all MIDI files in the directory
    for file in glob.glob(os.path.join(directory, "*.mid")):

        if tool == "piano":
            notes_list.extend(parse_piano(file))
        elif tool == "drums":
            notes_list.extend(parse_drums(file))
            # clean it
            notes_list = clean_notes(notes_list)
        elif tool == "guitar":
            notes_list.extend(parse_guitar(file))
            # clean it
            notes_list = clean_notes(notes_list)
        else:
            print(f'Unrecognized Instrument')
            return

    # Save the notes list as a binary file
    with open(f'{big_dir}/{tool}_notes', 'wb') as file_path:
        pickle.dump(notes_list, file_path)

    # print(f'Will return: {notes_list}') 
    return notes_list

# liss = retrieve_notes('/content/Notebooks_Weights_Music/Music/guitar_music_input')

# liss

# len(liss)

# len(set(liss))

def prepare_data_sequences(notes_list, n_pitch_names, pitch_names=None, sequence_length=10):
    """ Prepares input sequences and output labels for the Neural Network """

    # Get all unique pitch names from the notes list
    if pitch_names is None:
        pitch_names = sorted(set(item for item in notes_list))

    # Map pitch names to integers using a dictionary
    name_to_int = dict((name, number) for number, name in enumerate(pitch_names))

    network_input = []
    network_output = []

    # Create input sequences and corresponding output labels
    for i in range(0, len(notes_list) - sequence_length, 1):
        sequence_in = notes_list[i:i + sequence_length]
        sequence_out = notes_list[i + sequence_length]
        network_input.append([name_to_int[name] for name in sequence_in])
        network_output.append(name_to_int[sequence_out])

    num_patterns = len(network_input)

    # Reshape the input sequences for compatibility with LSTM layers
    normalized_input = numpy.reshape(network_input, (num_patterns, sequence_length, 1))

    # Normalize input sequences
    normalized_input = normalized_input / float(n_pitch_names)

    # Convert output labels to categorical one-hot vectors
    network_output = np_utils.to_categorical(network_output)

    return normalized_input, network_output, network_input

"""generating midi"""

def generate_piano_midi(prediction_output, file_path, program_number=1):
    output_notes = []
    offset = 0
    for pattern in prediction_output:
        # If the pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.offset = offset
                new_note.program = program_number
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # If the pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.program = program_number
            output_notes.append(new_note)

        # Increment the offset by a certain amount
        offset += 0.5

    # Convert the list of notes to a MIDI stream
    midi_stream = stream.Stream(output_notes)

    # Write the MIDI file to disk
    midi_stream.write('midi', fp=f'{file_path}')

def generate_drums_midi(note_names, file_path):
    # Create a new PrettyMIDI object
    midi_data = pretty_midi.PrettyMIDI()

    # Create a new instrument and add notes to it
    drum_track = pretty_midi.Instrument(program=0, is_drum=True, name='Drum Track')
    current_time = 0
    for note_name in note_names:
        note_number = pretty_midi.note_name_to_number(note_name)
        note = pretty_midi.Note(
            velocity=100,
            pitch=note_number,
            start=current_time,
            end=current_time+0.5
        )
        drum_track.notes.append(note)
        current_time += 0.5

    # Add a long note to hold until the end of the track
    end_time = midi_data.get_end_time()
    long_note = pretty_midi.Note(
        velocity=100,
        pitch=pretty_midi.note_name_to_number('C2'),
        start=current_time,
        end=end_time
    )
    drum_track.notes.append(long_note)

    # Add the drum track to the MIDI data
    midi_data.instruments.append(drum_track)

    # Write the MIDI data to a file
    midi_data.write(f'{file_path}')

def generate_guitar_midi(note_names, file_path):
    # Create a new PrettyMIDI object
    midi_data = pretty_midi.PrettyMIDI()

    # Create a new instrument and add notes to it
    guitar = pretty_midi.Instrument(program=25, name='Acoustic Guitar')
    current_time = 0
    for note_name in note_names:
        note_number = pretty_midi.note_name_to_number(note_name)
        
        # Check if the note number is within the range of valid MIDI note numbers
        if 0 <= note_number <= 127:
            # Create the note object and add it to the guitar track
            note = pretty_midi.Note(
                velocity=min(100, max(0, int(random.gauss(80, 10)))),  # limit velocity to 0-100
                pitch=note_number,
                start=current_time,
                end=current_time+0.5
            )
            guitar.notes.append(note)
        current_time += 0.5

    # Add a long note to hold until the end of the track
    end_time = midi_data.get_end_time()
    long_note = pretty_midi.Note(
        velocity=0,
        pitch=pretty_midi.note_name_to_number('C2'),
        start=current_time,
        end=end_time
    )
    guitar.notes.append(long_note)

    # Add the guitar track to the MIDI data
    midi_data.instruments.append(guitar)

    # Write the MIDI data to a file
    midi_data.write(f'{file_path}')

# def generate_guitar_midi(note_names, file_path):
#     # Create a new PrettyMIDI object
#     midi_data = pretty_midi.PrettyMIDI()

#     # Create a new instrument and add notes to it
#     guitar = pretty_midi.Instrument(program=25, name='Acoustic Guitar')
#     current_time = 0
#     for note_name in note_names:
#         note_number = pretty_midi.note_name_to_number(note_name)
#         note = pretty_midi.Note(
#             velocity=100,
#             pitch=note_number,
#             start=current_time,
#             end=current_time+0.5
#         )
#         guitar.notes.append(note)
#         current_time += 0.5

#     # Add a long note to hold until the end of the track
#     end_time = midi_data.get_end_time()
#     long_note = pretty_midi.Note(
#         velocity=0,
#         pitch=pretty_midi.note_name_to_number('C2'),
#         start=current_time,
#         end=end_time
#     )
#     guitar.notes.append(long_note)

#     # Add the guitar track to the MIDI data
#     midi_data.instruments.append(guitar)

#     # Write the MIDI data to a file
#     midi_data.write(f'{file_path}')

# def generate_midi(prediction_output, file_path, program_number=1):
#     """
#     Generate a MIDI file based on the output of the prediction using a specific program number.
#     """
#     if program_number == 116:
#         generate_drum_midi(prediction_output, file_path)
#     elif program_number == 25:
#         generate_guitar_midi(prediction_output, file_path)
#     else: # piano
#         generate_piano_midi(prediction_output, file_path, program_number)

"""# The Neural Network (NN) Training Functions:"""

def create_neural_network(input_data, vocabulary_size, weights_file=None):
    """ Build a neural network with the given input data and vocabulary size """
    model = Sequential()
    model.add(LSTM(
        512,
        input_shape=(input_data.shape[1], input_data.shape[2]),
        return_sequences=True
    ))
    model.add(LSTM(512, return_sequences=True,))
    model.add(LSTM(512))
    model.add(BatchNorm())
    model.add(Dense(256))
    model.add(Activation('relu'))
    model.add(BatchNorm())
    model.add(Dense(vocabulary_size))
    model.add(Activation('softmax'))
    model.compile(loss='categorical_crossentropy', optimizer='adam')

    # print(f'weights_file: {weights_file}')
    # Load the weights to each node
    try:
        model.load_weights(weights_file)
        print("# DONE weights loading #")
    except:
        print("weights loading error!")

    return model

def train_model(model, input_data, output_data, save_dir="/content/gdrive/MyDrive/MUSIC_GEN_PROJECT/check_points"):
    """ Train the given neural network """

    if not os.path.exists(save_dir):
        os.makedirs(save_dir)

    optimizer = Adam(learning_rate=0.0007)
    model.compile(optimizer=optimizer, loss='categorical_crossentropy')

    checkpoint_path = os.path.join(save_dir, "weights-{epoch:02d}-{loss:.4f}.hdf5")
    checkpoint_callback = ModelCheckpoint(
        checkpoint_path,
        monitor='loss',
        verbose=0,
        save_best_only=True,
        mode='min'
    )
    callbacks_list = [checkpoint_callback]

    history = model.fit(input_data, output_data, epochs=200, batch_size=1500, callbacks=callbacks_list)
    loss_list = history.history['loss']

    return loss_list

def get_notes_from_folder(music_path=None, tool="piano"):
    musical_notes = []
    if music_path is None:
        print("You should provide music path")
        return
    else:
        try:
            with (open(f'{music_path}/{tool}_notes', "rb")) as openfile:
                while True:
                    try:
                        musical_notes.append(pickle.load(openfile))
                    except EOFError:
                        break
        except:
            print("Needs: Creating Notes Filee")
            retrieve_notes(f'{music_path}/{tool}_music_input')
            with (open(f'{music_path}/{tool}_notes', "rb")) as openfile:
                while True:
                    try:
                        musical_notes.append(pickle.load(openfile))
                    except EOFError:
                        break
    return musical_notes

def train_music_generator(music_path=None, tool="piano", weights_path=None):
    """ The main function for Trainning a NN to generate music """

    musical_notes = get_notes_from_folder(music_path, tool)
    musical_notes = musical_notes[0]
    # Count the number of unique musical pitches
    pitch_count = len(set(musical_notes))
    print(f'Number of Unique Notes: {pitch_count}')

    input_sequences, output_sequences, _ = prepare_data_sequences(musical_notes, pitch_count)

    neural_network = create_neural_network(input_sequences, pitch_count, weights_path)

    print(f'input_sequences: {input_sequences.shape}')
    print(f'output_sequences: {output_sequences.shape}')
    # Train the model using input and output sequences
    loss_list = train_model(neural_network, input_sequences, output_sequences)
    return loss_list

"""# Training:"""

# losslist = train_music_generator('/content/Notebooks_Weights_Music/Music', 'guitar', '/content/Notebooks_Weights_Music/Weights/weights-199-0.3115.hdf5')

# import matplotlib.pyplot as plt

# def plot_loss(loss_list):
#     """Plot the loss values over epochs"""
#     plt.plot(loss_list)
#     plt.title('Guitar Model Loss (fourth time)')
#     plt.ylabel('Loss')
#     plt.xlabel('Epoch')
#     plt.show()
#     plt.savefig('LOSS.png')

# plot_loss(losslist)

"""# The Music Generation functions:"""

def generate_notes(neural_network, network_input, pitch_names, num_vocab, num_to_gen=100):
    """Generate a list of notes from the NN given a sequence of notes."""
    
    # Pick a random sequence as starting point for prediction
    start_point = numpy.random.randint(0, len(network_input) - 1)
    # Create a dictionary that maps integer to pitch names
    int_to_pitch = dict((num, pitch) for num, pitch in enumerate(pitch_names))

    pattern = network_input[start_point]
    output_notes = []

    # Generate notes
    for note_index in range(num_to_gen):
        input_sequence = numpy.reshape(pattern, (1, len(pattern), 1))
        # print(f'input_sequence(before): {input_sequence}')
        input_sequence = input_sequence / float(num_vocab)

        # Make prediction based on the input sequence
        prediction = neural_network.predict(input_sequence, verbose=0)

        # Get the index of the highest probability
        index = np.random.choice(num_vocab, p=prediction.ravel())
        # Map the integer index to pitch name
        predicted_pitch = int_to_pitch[index]
        # Append the predicted pitch to the output list
        output_notes.append(predicted_pitch)

        # Add the predicted pitch to the pattern and remove the first element
        pattern.append(index)
        pattern = pattern[1:len(pattern)]
    return output_notes

def generate_music(num_to_gen=100, music_path=None, file_name="test_out", tool='piano'):
    """ The main Generating function for a music file using a trained NN """
    notes = get_notes_from_folder(music_path, tool)
    big_dir = '/'.join(music_path.split('/')[:-1])
    weights_path = f'{big_dir}/Weights/{tool}-weights.hdf5'

    notes = notes[0] #adjust
    
    # Get all unique pitch names
    pitch_names = sorted(set(note for note in notes))
    # Get the number of unique pitch names
    n_vocab = len(set(notes))
    print(f'Num of Uniques: {n_vocab}')
    # Prepare the data sequences for the network
    normalized_input, _, network_input = prepare_data_sequences(notes, n_vocab, pitch_names)

    # Create the Neural Network model
    model = create_neural_network(normalized_input, n_vocab, weights_file=weights_path)

    # Generate music using the trained model
    generated_notes = generate_notes(model, network_input, pitch_names, n_vocab, num_to_gen)

    # Create a midi file from the generated notes (based on tool)
    midi_file_path = f'{file_name}.mid'
    if tool == "piano":
        generate_piano_midi(generated_notes, midi_file_path)
    elif tool == "drums":
        generate_drums_midi(generated_notes, midi_file_path)
    elif tool == "guitar":
        generate_guitar_midi(generated_notes, midi_file_path)

    # ############ Convert To Audio ###########
    # # Create a FluidSynth instance
    # fs = FluidSynth()
    # # Convert the MIDI file to WAV format
    # print("huh")
    # fs.midi_to_audio(midi_file_path, f'{file_name}.mp3')
    # print("huh")

"""# Generation:

To know more about all possible instruments: [Check This Link](https://en.wikipedia.org/wiki/General_MIDI#Parameter_interpretations)
"""

# generate_music(num_to_gen=100, music_path="/content/Notebooks_Weights_Music/Music", file_name="guitar_music", tool='guitar')

